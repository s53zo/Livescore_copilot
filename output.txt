===== ./score_reporter.py =====
#!/usr/bin/env python3
import sqlite3
import os
import logging
import traceback
from datetime import datetime, timedelta
from flask import request
import sys
from sql_queries import (CALCULATE_RATES, CALCULATE_BAND_RATES,
                        GET_BAND_BREAKDOWN, GET_BAND_BREAKDOWN_WITH_RATES,
                        GET_FILTERS, INSERT_CONTEST_DATA, INSERT_BAND_BREAKDOWN,
                        INSERT_QTH_INFO)

class RateCalculator:
    def __init__(self, db_path, debug=False):
        self.db_path = db_path
        self.debug = debug
        self.setup_logging()

    def setup_logging(self):
        """Setup logging configuration"""
        self.logger = logging.getLogger('RateCalculator')
        if not self.logger.handlers:
            formatter = logging.Formatter(
                '%(asctime)s - %(levelname)s - %(message)s'
            )
            console_handler = logging.StreamHandler()
            console_handler.setFormatter(formatter)
            self.logger.addHandler(console_handler)
            self.logger.setLevel(logging.DEBUG if self.debug else logging.INFO)

    def calculate_rates(self, cursor, callsign, contest, timestamp, long_window=60, short_window=15):
        """Calculate QSO rates using centralized SQL query"""
        try:
            current_ts = datetime.strptime(timestamp, '%Y-%m-%d %H:%M:%S')
            
            # Calculate long window rate
            long_window_start = current_ts - timedelta(minutes=long_window)
            cursor.execute(CALCULATE_RATES, (callsign, contest, 
                           long_window_start.strftime('%Y-%m-%d %H:%M:%S'),
                           current_ts.strftime('%Y-%m-%d %H:%M:%S'),
                           long_window_start.strftime('%Y-%m-%d %H:%M:%S')))
            row = cursor.fetchone()
            long_rate = int(round(row[0] * 60 / long_window)) if row and row[0] else 0
    
            # Calculate short window rate
            short_window_start = current_ts - timedelta(minutes=short_window) 
            cursor.execute(CALCULATE_RATES, (callsign, contest,
                           short_window_start.strftime('%Y-%m-%d %H:%M:%S'),
                           current_ts.strftime('%Y-%m-%d %H:%M:%S'),
                           short_window_start.strftime('%Y-%m-%d %H:%M:%S')))
            row = cursor.fetchone()
            short_rate = int(round(row[0] * 60 / short_window)) if row and row[0] else 0
    
            return long_rate, short_rate
                
        except Exception as e:
            self.logger.error(f"Error calculating rates: {e}")
            self.logger.debug(traceback.format_exc())
            return 0, 0
    
    def calculate_band_rates(self, cursor, callsign, contest, timestamp, long_window=60, short_window=15):
        """Calculate per-band QSO rates using centralized SQL query"""
        try:
            current_ts = datetime.strptime(timestamp, '%Y-%m-%d %H:%M:%S')
            
            # Get current band data
            cursor.execute(GET_BAND_BREAKDOWN, (callsign, contest, timestamp))
            band_data = {row[0]: [row[1], row[2], 0, 0] for row in cursor.fetchall()}
    
            # Calculate long window rates
            long_window_start = current_ts - timedelta(minutes=long_window)
            cursor.execute(CALCULATE_BAND_RATES, (callsign, contest, 
                           long_window_start.strftime('%Y-%m-%d %H:%M:%S'),
                           current_ts.strftime('%Y-%m-%d %H:%M:%S'),
                           long_window_start.strftime('%Y-%m-%d %H:%M:%S')))
            for row in cursor.fetchall():
                band = row[0]
                if band in band_data:
                    band_data[band][2] = int(round(row[1] * 60 / long_window))
            
            # Calculate short window rates
            short_window_start = current_ts - timedelta(minutes=short_window)
            cursor.execute(CALCULATE_BAND_RATES, (callsign, contest,
                           short_window_start.strftime('%Y-%m-%d %H:%M:%S'),
                           current_ts.strftime('%Y-%m-%d %H:%M:%S'),
                           short_window_start.strftime('%Y-%m-%d %H:%M:%S')))
            for row in cursor.fetchall():
                band = row[0]
                if band in band_data:
                    band_data[band][3] = int(round(row[1] * 60 / short_window))
            
            return band_data
                
        except Exception as e:
            self.logger.error(f"Error calculating band rates: {e}")
            self.logger.debug(traceback.format_exc())
            return {}

class ScoreReporter:
    def __init__(self, db_path=None, template_path=None, rate_minutes=60):
        """Initialize the ScoreReporter class"""
        self.db_path = db_path or 'contest_data.db'
        self.template_path = template_path or 'templates/score_template.html'
        self.rate_calculator = RateCalculator(self.db_path)
        self.setup_logging()

    def setup_logging(self):
        """Setup logging configuration with both file and console handlers"""
        try:
            # Create logger
            self.logger = logging.getLogger('ScoreReporter')
            self.logger.setLevel(logging.DEBUG)
            
            # Clear any existing handlers
            if self.logger.handlers:
                self.logger.handlers.clear()
            
            # Create logs directory if it doesn't exist
            log_dir = '/opt/livescore/logs'
            os.makedirs(log_dir, exist_ok=True)
            
            # Create formatters
            detailed_formatter = logging.Formatter(
                '%(asctime)s - %(levelname)s - [%(filename)s:%(lineno)d] - %(message)s'
            )
            console_formatter = logging.Formatter(
                '%(asctime)s - %(levelname)s - %(message)s'
            )
            
            # File handler for detailed debugging
            debug_log = os.path.join(log_dir, 'score_reporter.log')
            file_handler = logging.FileHandler(debug_log)
            file_handler.setLevel(logging.DEBUG)
            file_handler.setFormatter(detailed_formatter)
            
            # Console handler for basic info
            console_handler = logging.StreamHandler(sys.stdout)
            console_handler.setLevel(logging.INFO)
            console_handler.setFormatter(console_formatter)
            
            # Add handlers to logger
            self.logger.addHandler(file_handler)
            self.logger.addHandler(console_handler)
            
        except Exception as e:
            print(f"Error setting up logging: {e}", file=sys.stderr)
            print(traceback.format_exc(), file=sys.stderr)
            raise
        
    def get_station_details(self, callsign, contest, filter_type=None, filter_value=None):
        try:
            with sqlite3.connect(self.db_path) as conn:
                cursor = conn.cursor()
                
                # Start building query
                base_query = """
                    WITH ranked_stations AS (
                        SELECT 
                            cs.id,
                            cs.callsign,
                            cs.score,
                            cs.power,
                            cs.assisted,
                            cs.timestamp,
                            cs.qsos,
                            cs.multipliers,
                            ROW_NUMBER() OVER (ORDER BY cs.score DESC) as position
                        FROM contest_scores cs
                        JOIN qth_info qi ON qi.contest_score_id = cs.id
                        WHERE cs.contest = ?
                        AND cs.id IN (
                            SELECT MAX(id)
                            FROM contest_scores
                            WHERE contest = ?
                            GROUP BY callsign
                        )
                """
                
                params = [contest, contest]
                
                # Add QTH filter if specified
                if filter_type and filter_value and filter_type.lower() != 'none':
                    filter_map = {
                        'DXCC': 'qi.dxcc_country',
                        'CQ Zone': 'qi.cq_zone',
                        'IARU Zone': 'qi.iaru_zone',
                        'ARRL Section': 'qi.arrl_section',
                        'State/Province': 'qi.state_province',
                        'Continent': 'qi.continent'
                    }
                    
                    if field := filter_map.get(filter_type):
                        base_query += f" AND {field} = ?"
                        params.append(filter_value)
                
                base_query += ")"  # Close the CTE
                
                # Handle position filtering
                position_filter = request.args.get('position_filter', 'all')
                if position_filter == 'range':
                    query = base_query + """
                        SELECT rs.*, 
                               CASE WHEN rs.callsign = ? THEN 'current'
                                    WHEN rs.score > (SELECT score FROM ranked_stations WHERE callsign = ?) 
                                    THEN 'above' ELSE 'below' END as rel_pos
                        FROM ranked_stations rs
                        WHERE EXISTS (
                            SELECT 1 FROM ranked_stations ref 
                            WHERE ref.callsign = ? 
                            AND ABS(rs.position - ref.position) <= 5
                        )
                        ORDER BY rs.score DESC
                    """
                else:
                    query = base_query + """
                        SELECT rs.*, 
                               CASE WHEN rs.callsign = ? THEN 'current'
                                    WHEN rs.score > (SELECT score FROM ranked_stations WHERE callsign = ?) 
                                    THEN 'above' ELSE 'below' END as rel_pos
                        FROM ranked_stations rs
                        ORDER BY rs.score DESC
                    """
                
                params.extend([callsign, callsign, callsign])

                cursor.execute(query, params)
                return cursor.fetchall()
    
        except Exception as e:
            self.logger.error(f"Error in get_station_details: {e}")
            self.logger.error(traceback.format_exc())
            return None

    def get_band_breakdown_with_rates(self, station_id, callsign, contest, timestamp):
        """Get band breakdown with both 60-minute and 15-minute rates"""
        try:
            with sqlite3.connect(self.db_path) as conn:
                cursor = conn.cursor()
                params = (
                    callsign, contest, timestamp,                  # current_score parameters (3)
                    callsign, contest, timestamp, timestamp,       # long_window_score parameters (4)
                    callsign, contest, timestamp, timestamp        # short_window_score parameters (4)
                )
                
                cursor.execute(GET_BAND_BREAKDOWN_WITH_RATES, params)
                results = cursor.fetchall()
                band_data = {}
                
                for row in results:
                    band, current_qsos, multipliers, long_window_qsos, short_window_qsos = row
                    
                    # Calculate 60-minute rate
                    long_rate = 0
                    if long_window_qsos is not None:
                        qso_diff = current_qsos - long_window_qsos
                        if qso_diff > 0:
                            long_rate = int(round((qso_diff * 60) / 60))  # 60-minute rate
                    
                    # Calculate 15-minute rate
                    short_rate = 0
                    if short_window_qsos is not None:
                        qso_diff = current_qsos - short_window_qsos
                        if qso_diff > 0:
                            short_rate = int(round((qso_diff * 60) / 15))  # Convert 15-minute to hourly rate
                    
                    band_data[band] = [current_qsos, multipliers, long_rate, short_rate]
                
                return band_data
                        
        except Exception as e:
            self.logger.error(f"Error in get_band_breakdown_with_rates: {e}")
            self.logger.error(traceback.format_exc())
            return {}

    def get_total_rates(self, station_id, callsign, contest, timestamp):
        """Get total QSO rates for both time windows"""
        try:
            with sqlite3.connect(self.db_path) as conn:
                cursor = conn.cursor()
                return self.rate_calculator.calculate_rates(
                    cursor, callsign, contest, timestamp
                )
        except Exception as e:
            self.logger.error(f"Error in get_total_rates: {e}")
            self.logger.error(traceback.format_exc())
            return 0, 0

    def generate_html_content(self, template, callsign, contest, stations):
        """Generate HTML content from template and data"""
        try:
            from html import escape
            import re
            
            # Escape all data values
            safe_callsign = escape(callsign)
            safe_contest = escape(contest)
            
            # Prepare station data
            station_rows = []
            for station in stations:
                safe_station = [escape(str(x)) if x is not None else '' for x in station]
                station_rows.append(safe_station)
            
            # Create template variables
            template_vars = {
                'callsign': safe_callsign,
                'contest': safe_contest,
                'stations': station_rows,
                'timestamp': datetime.now().strftime('%Y-%m-%d %H:%M:%S'),
                'table_rows': ''.join(f'<tr>{"".join(f"<td>{cell}</td>" for cell in row)}</tr>' for row in station_rows),
                'filter_info_div': '<div class="filter-info">No filters applied</div>',
                'additional_css': '',
                'power': 'High',
                'assisted': 'Assisted'
            }
            
            # Perform template substitution for both {var} and {{var}} syntax
            def replace_var(match):
                var_name = match.group(1)
                return str(template_vars.get(var_name, ''))
            
            # First replace {variable} patterns (Python template variables)
            html_content = re.sub(r'\{(\w+)\}', replace_var, template)
            # Then replace {{variable}} patterns (JavaScript template literals)
            # Only replace if they're not inside <script> tags
            def js_replace(match):
                if match.group(0).startswith('{{') and '</script>' not in match.string[:match.start()]:
                    return str(template_vars.get(match.group(1), ''))
                return match.group(0)
            
            html_content = re.sub(r'\{\{(\w+)\}\}', js_replace, html_content)
            
            return html_content
            
        except Exception as e:
            self.logger.error(f"Error generating HTML content: {e}")
            self.logger.error(traceback.format_exc())
            return "<h1>Error generating report</h1>"

    # ... (rest of the ScoreReporter class remains unchanged)

===== ./sql_queries.py =====
# SQL Queries for LiveScore Contest Reporting System

# Contest queries
GET_CONTESTS = """
    SELECT contest, COUNT(DISTINCT callsign) AS active_stations
    FROM contest_scores
    GROUP BY contest
    ORDER BY contest
"""

GET_CALLSIGNS = """
    WITH latest_scores AS (
        SELECT cs.callsign, cs.qsos, cs.timestamp
        FROM contest_scores cs
        INNER JOIN (
            SELECT callsign, MAX(timestamp) as max_ts
            FROM contest_scores
            WHERE contest = ?
            GROUP BY callsign
        ) latest ON cs.callsign = latest.callsign 
            AND cs.timestamp = latest.max_ts
        WHERE cs.contest = ?
        AND cs.qsos > 0
    )
    SELECT DISTINCT callsign, qsos as qso_count
    FROM latest_scores
    ORDER BY callsign
"""

API_GET_CALLSIGNS = """
    SELECT DISTINCT callsign
    FROM contest_scores
    WHERE contest = ?
    AND qsos > 0
    ORDER BY callsign
"""

VERIFY_STATION = """
    SELECT COUNT(*) 
    FROM contest_scores
    WHERE contest = ?
    AND callsign = ?
"""

GET_FILTERS = """
    SELECT qi.dxcc_country, qi.cq_zone, qi.iaru_zone, 
           qi.arrl_section, qi.state_province, qi.continent
    FROM contest_scores cs
    JOIN qth_info qi ON qi.contest_score_id = cs.id
    WHERE cs.contest = ? AND cs.callsign = ?
    ORDER BY cs.timestamp DESC
    LIMIT 1
"""

# Rate calculation queries
CALCULATE_RATES = """
    WITH now AS (
        SELECT datetime('now') as current_utc
    ),
    total_qsos AS (
        SELECT cs.timestamp, SUM(bb.qsos) as total
        FROM contest_scores cs
        JOIN band_breakdown bb ON bb.contest_score_id = cs.id
        CROSS JOIN now n 
        WHERE cs.callsign = ? 
        AND cs.contest = ?
        AND cs.timestamp >= ?
        AND cs.timestamp <= ?
        AND (julianday(n.current_utc) - julianday(cs.timestamp)) * 24 * 60 <= 75
        GROUP BY cs.timestamp
        ORDER BY cs.timestamp DESC
    )
    SELECT 
        MAX(total) - MIN(total) as qso_diff,
        COUNT(*) as samples,
        MAX(timestamp) as latest,
        MIN(timestamp) as earliest
    FROM total_qsos
    WHERE timestamp >= ?
"""

CALCULATE_BAND_RATES = """
    WITH now AS (
        SELECT datetime('now') as current_utc
    ),
    band_qsos AS (
        SELECT cs.timestamp, bb.band, bb.qsos
        FROM contest_scores cs
        JOIN band_breakdown bb ON bb.contest_score_id = cs.id
        CROSS JOIN now n
        WHERE cs.callsign = ? 
        AND cs.contest = ?
        AND cs.timestamp >= ?
        AND cs.timestamp <= ?
        AND (julianday(n.current_utc) - julianday(cs.timestamp)) * 24 * 60 <= 75
        ORDER BY cs.timestamp DESC
    )
    SELECT 
        band,
        MAX(qsos) - MIN(qsos) as qso_diff,
        COUNT(*) as samples,
        MAX(timestamp) as latest,
        MIN(timestamp) as earliest
    FROM band_qsos
    WHERE timestamp >= ?
    GROUP BY band
    HAVING qso_diff > 0
"""

# Station details query
# GET_STATION_DETAILS query has been moved to score_reporter.py
# where it is now dynamically built based on filter parameters

# Band breakdown queries
GET_BAND_BREAKDOWN = """
    SELECT bb.band, bb.qsos, bb.multipliers
    FROM contest_scores cs
    JOIN band_breakdown bb ON bb.contest_score_id = cs.id
    WHERE cs.callsign = ?
    AND cs.contest = ?
    AND cs.timestamp = ?
    AND bb.qsos > 0
    ORDER BY bb.band
"""

GET_BAND_BREAKDOWN_WITH_RATES = """
    WITH current_score AS (
        SELECT cs.id, cs.timestamp, bb.band, bb.qsos, bb.multipliers
        FROM contest_scores cs
        JOIN band_breakdown bb ON bb.contest_score_id = cs.id
        WHERE cs.callsign = ? 
        AND cs.contest = ?
        AND cs.timestamp = ?
    ),
    long_window_score AS (
        SELECT bb.band, bb.qsos
        FROM contest_scores cs
        JOIN band_breakdown bb ON bb.contest_score_id = cs.id
        WHERE cs.callsign = ?
        AND cs.contest = ?
        AND cs.timestamp <= datetime(?, '-60 minutes')
        AND cs.timestamp >= datetime(?, '-65 minutes')
        ORDER BY cs.timestamp DESC
    ),
    short_window_score AS (
        SELECT bb.band, bb.qsos
        FROM contest_scores cs
        JOIN band_breakdown bb ON bb.contest_score_id = cs.id
        WHERE cs.callsign = ?
        AND cs.contest = ?
        AND cs.timestamp <= datetime(?, '-15 minutes')
        AND cs.timestamp >= datetime(?, '-20 minutes')
        ORDER BY cs.timestamp DESC
    )
    SELECT 
        cs.band,
        cs.qsos as current_qsos,
        cs.multipliers,
        lws.qsos as long_window_qsos,
        sws.qsos as short_window_qsos
    FROM current_score cs
    LEFT JOIN long_window_score lws ON cs.band = lws.band
    LEFT JOIN short_window_score sws ON cs.band = sws.band
    WHERE cs.qsos > 0
    ORDER BY cs.band
"""

# Database schema queries
CREATE_CONTEST_SCORES_TABLE = """
    CREATE TABLE IF NOT EXISTS contest_scores (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        timestamp DATETIME,
        contest TEXT,
        callsign TEXT,
        power TEXT,
        assisted TEXT,
        transmitter TEXT,
        ops TEXT,
        bands TEXT,
        mode TEXT,
        overlay TEXT,
        club TEXT,
        section TEXT,
        score INTEGER,
        qsos INTEGER,
        multipliers INTEGER,
        points INTEGER
    )
"""

CREATE_BAND_BREAKDOWN_TABLE = """
    CREATE TABLE IF NOT EXISTS band_breakdown (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        contest_score_id INTEGER,
        band TEXT,
        mode TEXT,
        qsos INTEGER,
        points INTEGER,
        multipliers INTEGER,
        FOREIGN KEY (contest_score_id) REFERENCES contest_scores(id)
    )
"""

CREATE_QTH_INFO_TABLE = """
    CREATE TABLE IF NOT EXISTS qth_info (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        contest_score_id INTEGER,
        dxcc_country TEXT,
        cq_zone TEXT,
        iaru_zone TEXT,
        arrl_section TEXT,
        state_province TEXT,
        grid6 TEXT,
        FOREIGN KEY (contest_score_id) REFERENCES contest_scores(id)
    )
"""

# Data insertion queries
INSERT_QTH_INFO = """
    INSERT INTO qth_info (
        contest_score_id, dxcc_country, continent, cq_zone, 
        iaru_zone, arrl_section, state_province, grid6
    ) VALUES (?, ?, ?, ?, ?, ?, ?, ?)
"""

INSERT_BAND_BREAKDOWN = """
    INSERT INTO band_breakdown (
        contest_score_id, band, mode, qsos, points, multipliers
    ) VALUES (?, ?, ?, ?, ?, ?)
"""

INSERT_CONTEST_DATA = """
    INSERT INTO contest_scores (
        timestamp, contest, callsign, power, assisted, transmitter,
        ops, bands, mode, overlay, club, section, score, qsos,
        multipliers, points
    ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
"""

# Data consistency queries
CHECK_QSO_CONSISTENCY = """
    SELECT cs.id, cs.callsign, cs.qsos, SUM(bb.qsos) as total_band_qsos
    FROM contest_scores cs
    LEFT JOIN band_breakdown bb ON bb.contest_score_id = cs.id
    GROUP BY cs.id
    HAVING cs.qsos != total_band_qsos
    AND total_band_qsos IS NOT NULL
"""

COUNT_ORPHANED_BAND_BREAKDOWN = """
    SELECT COUNT(*) 
    FROM band_breakdown bb
    LEFT JOIN contest_scores cs ON cs.id = bb.contest_score_id
    WHERE cs.id IS NULL
"""

COUNT_ORPHANED_QTH_INFO = """
    SELECT COUNT(*) 
    FROM qth_info qi
    LEFT JOIN contest_scores cs ON cs.id = qi.contest_score_id
    WHERE cs.id IS NULL
"""

ANALYZE_ORPHANED_BAND_BREAKDOWN = """
    SELECT 
        bb.contest_score_id,
        COUNT(*) as record_count,
        SUM(bb.qsos) as total_qsos,
        GROUP_CONCAT(DISTINCT bb.band) as bands,
        MIN(bb.qsos) as min_qsos,
        MAX(bb.qsos) as max_qsos
    FROM band_breakdown bb
    LEFT JOIN contest_scores cs ON cs.id = bb.contest_score_id
    WHERE cs.id IS NULL
    GROUP BY bb.contest_score_id
    ORDER BY record_count DESC
    LIMIT 10
"""

ANALYZE_ORPHANED_QTH_INFO = """
    SELECT 
        qi.contest_score_id,
        qi.dxcc_country,
        qi.cq_zone,
        qi.iaru_zone,
        qi.arrl_section,
        qi.state_province
    FROM qth_info qi
    LEFT JOIN contest_scores cs ON cs.id = qi.contest_score_id
    WHERE cs.id IS NULL
    ORDER BY qi.contest_score_id DESC
    LIMIT 10
"""

DELETE_ORPHANED_BAND_BREAKDOWN = """
    DELETE FROM band_breakdown
    WHERE contest_score_id IN (
        SELECT bb.contest_score_id
        FROM band_breakdown bb
        LEFT JOIN contest_scores cs ON cs.id = bb.contest_score_id
        WHERE cs.id IS NULL
    )
"""

DELETE_ORPHANED_QTH_INFO = """
    DELETE FROM qth_info
    WHERE contest_score_id IN (
        SELECT qi.contest_score_id
        FROM qth_info qi
        LEFT JOIN contest_scores cs ON cs.id = qi.contest_score_id
        WHERE cs.id IS NULL
    )
"""

FIND_SMALL_CONTESTS = """
    SELECT contest, COUNT(DISTINCT callsign) as num_callsigns
    FROM contest_scores
    GROUP BY contest
    HAVING num_callsigns < 5
"""

GET_OLD_RECORDS = """
    SELECT id
    FROM contest_scores
    WHERE timestamp < ?
"""

GET_ARCHIVE_RECORDS = """
    SELECT id, contest, timestamp
    FROM contest_scores
    WHERE timestamp < ?
    ORDER BY timestamp DESC
"""

# Data deletion queries
DELETE_BAND_BREAKDOWN_BY_CONTEST_SCORE_ID = """
    DELETE FROM band_breakdown
    WHERE contest_score_id IN (
        SELECT id FROM contest_scores WHERE contest = ?
    )
"""

DELETE_QTH_INFO_BY_CONTEST_SCORE_ID = """
    DELETE FROM qth_info
    WHERE contest_score_id IN (
        SELECT id FROM contest_scores WHERE contest = ?
    )
"""

DELETE_CONTEST_SCORES_BY_CONTEST = """
    DELETE FROM contest_scores
    WHERE contest = ?
"""

===== ./web_interface.py =====
#!/usr/bin/env python3
from flask import Flask, render_template, request, redirect, send_from_directory, jsonify, make_response
import sqlite3
import os
import logging
import sys
import traceback
import sql_queries
from score_reporter import ScoreReporter
from datetime import datetime

# Define Config class first
class Config:
    DB_PATH = '/opt/livescore/contest_data.db'
    OUTPUT_DIR = '/opt/livescore/reports'

# Set up detailed logging
logging.basicConfig(
    level=logging.ERROR,
    format='%(asctime)s - %(levelname)s - [%(filename)s:%(lineno)d] - %(message)s',
    handlers=[
        logging.FileHandler('/opt/livescore/logs/debug.log'),
        logging.StreamHandler(sys.stdout)
    ]
)
logger = logging.getLogger(__name__)

# Log startup
logger.info("Starting web interface application")

try:
    # Create Flask app
    app = Flask(__name__)
    logger.info("Flask app created successfully")

except Exception as e:
    logger.error(f"Failed to create Flask app")
    logger.error(traceback.format_exc())
    raise

class Config:
    DB_PATH = '/opt/livescore/contest_data.db'
    OUTPUT_DIR = '/opt/livescore/reports'

def get_db():
    """Database connection with logging"""
    logger.debug("Attempting database connection")
    try:
        conn = sqlite3.connect(Config.DB_PATH)
        logger.debug("Database connection successful")
        return conn
    except Exception as e:
        logger.error(f"Database connection failed: {str(e)}")
        logger.error(traceback.format_exc())
        raise



@app.route('/livescore-pilot', methods=['GET', 'POST'])
def index():
    logger.debug(f"Request received: {request.method}")
    
    try:
        with get_db() as db:
            cursor = db.cursor()
            
            # Get contests with station counts
            cursor.execute(sql_queries.GET_CONTESTS)
            contests = [{"name": row[0], "count": row[1]} for row in cursor.fetchall()]
            
            # Get contest and callsign from form or query parameters
            selected_contest = request.form.get('contest') or request.args.get('contest')
            selected_callsign = request.form.get('callsign') or request.args.get('callsign')
            
            callsigns = []
            
            if selected_contest:
                # Fetch unique callsigns with their latest QSO count for the selected contest
                cursor.execute(sql_queries.GET_CALLSIGNS, (selected_contest, selected_contest))
                callsigns = [{"name": row[0], "qso_count": row[1]} for row in cursor.fetchall()]
                
        return render_template('select_form.html', 
                             contests=contests,
                             selected_contest=selected_contest,
                             selected_callsign=selected_callsign,
                             callsigns=callsigns)
    
    except Exception as e:
        logger.error("Exception in index route:")
        logger.error(traceback.format_exc())
        return render_template('error.html', error=f"Error: {str(e)}")

@app.route('/reports/live.html')
def live_report():
    try:
        # Get parameters from URL
        callsign = request.args.get('callsign')
        contest = request.args.get('contest')
        filter_type = request.args.get('filter_type', 'none')
        filter_value = request.args.get('filter_value', 'none')

        if not (callsign and contest):
            return render_template('error.html', error="Missing required parameters")

        logger.info(f"Generating report for: contest={contest}, callsign={callsign}, "
                   f"filter_type={filter_type}, filter_value={filter_value}")

        # Create reporter instance
        reporter = ScoreReporter(Config.DB_PATH)

        # Verify contest and callsign exist in database
        with get_db() as conn:
            cursor = conn.cursor()
            cursor.execute(sql_queries.VERIFY_STATION, (contest, callsign))
            if cursor.fetchone()[0] == 0:
                return render_template('error.html', 
                    error=f"No data found for {callsign} in {contest}")

        # Get station data with filters
        position_filter = request.args.get('position_filter', 'all')
        stations = reporter.get_station_details(
            callsign, 
            contest, 
            filter_type, 
            filter_value,
            position_filter
        )

        if stations:
            # Generate HTML content directly
            template_path = os.path.join(os.path.dirname(__file__), 'templates', 'score_template.html')
            with open(template_path, 'r') as f:
                template = f.read()

            html_content = reporter.generate_html_content(
                template, 
                callsign, 
                contest, 
                stations,
                filter_type,
                filter_value,
                position_filter
            )
            
            # Return response with appropriate headers
            response = make_response(html_content)
            response.headers['Content-Type'] = 'text/html; charset=utf-8'
            response.headers['Cache-Control'] = 'no-store, no-cache, must-revalidate, max-age=0'
            response.headers['Pragma'] = 'no-cache'
            response.headers['Expires'] = '0'
            
            logger.info(f"Successfully generated report for {callsign} in {contest}")
            return response
        else:
            logger.error(f"No station data found for {callsign} in {contest}")
            return render_template('error.html', error="No data found for the selected criteria")

    except Exception as e:
        logger.error("Exception in live_report:")
        logger.error(traceback.format_exc())
        return render_template('error.html', error=f"Error: {str(e)}")

@app.errorhandler(404)
def not_found_error(error):
    logger.error(f"404 error: {error}")
    return render_template('error.html', error="Page not found"), 404

@app.errorhandler(500)
def internal_error(error):
    logger.error(f"500 error: {error}")
    logger.error(traceback.format_exc())
    return render_template('error.html', error="Internal server error"), 500

@app.route('/livescore-pilot/api/contests')
def get_contests():
    try:
        with get_db() as db:
            cursor = db.cursor()
            cursor.execute(sql_queries.API_GET_CONTESTS)
            contests = [{"name": row[0], "count": row[1]} for row in cursor.fetchall()]
            return jsonify(contests)
    except Exception as e:
        logger.error(f"Error fetching contests: {str(e)}")
        return jsonify({"error": str(e)}), 500

@app.route('/livescore-pilot/api/callsigns')
def get_callsigns():
    contest = request.args.get('contest')
    if not contest:
        return jsonify({"error": "Contest parameter required"}), 400

    try:
        with get_db() as db:
            cursor = db.cursor()
            cursor.execute(sql_queries.API_GET_CALLSIGNS, (contest,))
            callsigns = [{"name": row[0]} for row in cursor.fetchall()]
            return jsonify(callsigns)
    except Exception as e:
        logger.error(f"Error fetching callsigns: {str(e)}")
        return jsonify({"error": str(e)}), 500

@app.route('/livescore-pilot/api/filters')
def get_filters():
    contest = request.args.get('contest')
    callsign = request.args.get('callsign')
    
    if not contest or not callsign:
        return jsonify({"error": "Contest and callsign parameters required"}), 400

    try:
        with get_db() as db:
            cursor = db.cursor()
            cursor.execute(sql_queries.GET_FILTERS, (contest, callsign))
            
            row = cursor.fetchone()
            if not row:
                return jsonify([])

            filters = []
            filter_map = {
                'DXCC': row[0],
                'CQ Zone': row[1],
                'IARU Zone': row[2],
                'ARRL Section': row[3],
                'State/Province': row[4],
                'Continent': row[5]
            }

            for filter_type, value in filter_map.items():
                if value:  # Only include non-empty values
                    filters.append({
                        "type": filter_type,
                        "value": value
                    })

            return jsonify(filters)
    except Exception as e:
        logger.error(f"Error fetching filters: {str(e)}")
        return jsonify({"error": str(e)}), 500

if __name__ == '__main__':
    logger.info("Starting development server")
    app.run(host='127.0.0.1', port=8089)
else:
    # When running under gunicorn
    logger.info("Starting under gunicorn")

